using gold.**

var  A  

procedure main(args:String[]) begin
	if  args.length=0  then  A:= {'a'}
	else	
		A := {args[0].charAt(i) |  0 ≤ i < args[0].length()}\{'&'}
    end
	GAutomataFrame.show(createFA())
	test(createFA())
end




function createFA():ITransducer begin
	Ls := A //alfabeto unicial
	M0 := {""} //estado inicial
	M1 := {""+a|a∈Ls} //estado secundario
	M2 := {""+a+b| a∈Ls,b∈Ls} // terciario
	M3 := {""+a+b+c|a∈Ls,b∈Ls,c∈Ls} //antefinal con tupla de completitud
	
	Q := {⟨s⟩ | s ∈ M0 ∪ M1 ∪ M2 ∪ M3} 
	∪ {⟨a, b, i⟩ | a ∈ M3, b ∈ (M1∪M2∪M3), 0 ≤ i ≤ 3} //a es actual, b es siguiente, i es aciertos
	∪ {⟨a, b, i, k⟩ | a ∈ M3, b ∈ (M1∪M2∪M3),
	0 ≤ i ≤ 3, k ∈ {'!', '*', '?', ""}} 
	∪ {"E", "F"} //estados posibles
	print Q
	
	Σ:= A ∪  {'&'} //alfabeto input
	O := Σ  ∪  { '!', '*', '?'} //alfabeto output
	q₀:=⟨""⟩ //estado inicial
	F:={"F"}  //estado final
	return GDeterministicTransducer(Q,Σ,O,q₀,F,δ,g,h)
end

g(x):= ""
procedure test(M:ITransducer) begin
	var sc:java.util.Scanner(System.$in)
	
		var string: String
			
			
		repeat 
		
			print "----------------------------"
			print "Input a string of the form xyz:W. with xyz and W  over "+A +"  (end with an empty string)"
			string:=sc.nextLine()
			if string ≠ λ then
				result:=M.acceptsString(string)
				print "The string was "+(result?"accepted":"not accepted")+". Output: "+M.getOutputString()		
			end
		until string=λ
	print "Execution Terminated"
end


function reverse(s:String):String begin
  var r:String 
  var i:int 
  
  r := ""
  i := s.length() - 1

  while i >= 0 do
    r := r + s.charAt(i)
    i := i - 1
  end

  return r
end


function isPalindrome(cadena) begin
  var left:int
  var right:int
  left := 0
  right := cadena.length() - 1

  while left < right do
    if cadena.charAt(left) ≠ cadena.charAt(right) then
      return false
    end
    left := left + 1
    right := right - 1
  end
  return true
end


function δ(q, σ) begin
  var actualPalabra:String
  var anteriorPalabra:String
  var progreso:int
  var salida:String
  var s:String
  var temp:String
  var nuevaPalabra:String

  if q = "E" or q = "F" then
    return "E"

  // ------------------ Si el símbolo es & -------------------
  elseif σ = '&' then
    if |q| = 1 then
      actualPalabra := q[0]
      temp := actualPalabra + ""
      if actualPalabra ≠ "&" and temp.length() = 3 then
        return ⟨actualPalabra, "", 0⟩
      else
        return "E"
      end

    elseif |q| = 3 then
      anteriorPalabra := q[0]
      actualPalabra := q[1]
      progreso := q[2]
      temp := actualPalabra + ""

      if progreso < 3 then
        return "E"
      else
        if temp.length() = 3 then
          return ⟨actualPalabra, "", 0⟩
        else
          return "E"
        end
      end

    elseif |q| = 4 then
      anteriorPalabra := q[0]
      actualPalabra := q[1]
      progreso := q[2]
      salida := q[3]
      temp := actualPalabra + ""

      if progreso = 3 and temp.length() = 3 then
        return ⟨actualPalabra, "", 0⟩
      else
        return "E"
      end

    else
      return "E"
    end

  // ------------------ Para construir w1 -------------------
  elseif |q| = 1 then
    s := q[0]
    if s.length() < 3 then
      return ⟨s + σ⟩
    else
      return "E"
    end

  // ------------------ Comparación  wi y wi-1 -------------------
  elseif |q| = 3 then
    anteriorPalabra := q[0]
    actualPalabra := q[1]
    progreso := q[2]
    
    if actualPalabra = "" and σ = '&' then
	    return "E"
	    end
	
	  if actualPalabra.length() < 2 then
	    return ⟨anteriorPalabra, actualPalabra + σ, progreso + 1⟩
    else
      nuevaPalabra := actualPalabra + σ

      if nuevaPalabra.length() ≠ 3 then
        return "E"
      end

      if nuevaPalabra = anteriorPalabra then
        if isPalindrome(anteriorPalabra) then
          return ⟨anteriorPalabra, nuevaPalabra, 3, "?"⟩
        else
          return ⟨anteriorPalabra, nuevaPalabra, 3, "*"⟩
        end
      elseif nuevaPalabra = reverse(anteriorPalabra) then
        return ⟨anteriorPalabra, nuevaPalabra, 3, "!"⟩
      else
        return ⟨anteriorPalabra, nuevaPalabra, 3, nuevaPalabra⟩
      end
    end

  // ------------------ Estado con símbolo de salida  -------------------
  elseif |q| = 4 then
    if σ = '&' then
      temp := q[1] + ""
      if temp.length() = 3 then
        return ⟨q[1], "", 0⟩
      else
        return "E"
      end
    else
      return "E"
    end

  else
    return "E"
  end
end

function h(q, σ) begin
  if |q| = 4 then
    return q[3] 
  else
    return ""
  end
end







 
